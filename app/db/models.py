"""
SQLAlchemy async models for PostgreSQL backend.

Purpose: Define database schema with typed columns + JSONB for dynamic fields.
Validation: Run alembic revision --autogenerate to verify model structure.

Key design decisions:
- Use string PKs (client_id, project_id) matching 8-char hex IDs from Sheets
- JSONB 'extra' column for dynamic/evolving schema fields
- GIN indexes on JSONB for fast queries
- created_at/updated_at for audit trail
"""

from datetime import datetime
from typing import Any, Dict
from sqlalchemy import String, Text, DateTime, Boolean, Numeric, Index, text, FetchedValue
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    """Base class for all models."""
    pass


class Client(Base):
    """
    Client/customer entity migrated from Google Sheets 'Clients' tab.
    
    Typed columns: frequently queried fields
    extra: JSONB for dynamic fields (custom fields, legacy columns)
    """
    __tablename__ = "clients"
    
    # Primary key - UUID for unique identification
    client_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (CL-00001, CL-00002, etc.)
    # Generated by database trigger, don't include in INSERT
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Core fields
    full_name: Mapped[str | None] = mapped_column(String(255), index=True)
    email: Mapped[str | None] = mapped_column(String(255), index=True)
    phone: Mapped[str | None] = mapped_column(String(50))
    address: Mapped[str | None] = mapped_column(Text)
    city: Mapped[str | None] = mapped_column(String(100))
    state: Mapped[str | None] = mapped_column(String(50))
    zip_code: Mapped[str | None] = mapped_column(String(20))
    
    # Business fields
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Active, Inactive, Lead
    client_type: Mapped[str | None] = mapped_column(String(50))  # Residential, Commercial
    
    # QuickBooks integration
    qb_customer_id: Mapped[str | None] = mapped_column(String(50), index=True)
    qb_display_name: Mapped[str | None] = mapped_column(String(255))
    qb_sync_status: Mapped[str | None] = mapped_column(String(50))  # synced, pending, error
    qb_last_sync: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Dynamic fields from Sheets
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit fields
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        # GIN index for JSONB queries
        Index('ix_clients_extra_gin', 'extra', postgresql_using='gin'),
        # Case-insensitive search on name
        Index('ix_clients_full_name_lower', text('lower(full_name)')),
    )


class Project(Base):
    """
    Project entity from 'Projects' sheet tab.
    
    Links to clients via client_id FK.
    """
    __tablename__ = "projects"
    
    # Primary key - UUID for unique identification
    project_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (PRJ-00001, PRJ-00002, etc.)
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign key to client
    client_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)
    
    # Core fields
    project_name: Mapped[str | None] = mapped_column(String(255))
    project_address: Mapped[str | None] = mapped_column(Text)
    project_type: Mapped[str | None] = mapped_column(String(100))  # Kitchen Remodel, Addition, etc.
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Planning, Active, Complete
    
    # Financial
    budget: Mapped[float | None] = mapped_column(Numeric(12, 2))
    actual_cost: Mapped[float | None] = mapped_column(Numeric(12, 2))
    
    # Timeline
    start_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    end_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    completion_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Notes and description
    description: Mapped[str | None] = mapped_column(Text)
    notes: Mapped[str | None] = mapped_column(Text)
    
    # QuickBooks
    qb_estimate_id: Mapped[str | None] = mapped_column(String(50))
    qb_invoice_id: Mapped[str | None] = mapped_column(String(50))
    
    # Phase Q: Qualifier Compliance (added Dec 2025)
    licensed_business_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # FK to licensed_businesses.id
    qualifier_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # FK to qualifiers.id
    engagement_model: Mapped[str | None] = mapped_column(String(100))  # "Internal GC", "Oversight Only", "Direct Hire"
    oversight_required: Mapped[bool | None] = mapped_column(Boolean)  # True if qualifier must provide oversight
    compliance_notes: Mapped[str | None] = mapped_column(Text)  # Compliance-specific notes
    
    # Dynamic fields
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        Index('ix_projects_extra_gin', 'extra', postgresql_using='gin'),
        Index('ix_projects_dates', 'start_date', 'end_date'),
    )


class Permit(Base):
    """
    Building permit tracking from 'Permits' sheet.
    """
    __tablename__ = "permits"
    
    # Primary key - UUID for unique identification
    permit_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (PER-00001, PER-00002, etc.)
    # Generated by database trigger, don't include in INSERT
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign keys
    project_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)
    client_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)
    
    # Permit details
    permit_number: Mapped[str | None] = mapped_column(String(100), unique=True, index=True)
    permit_type: Mapped[str | None] = mapped_column(String(100))  # Building, Electrical, Plumbing
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Pending, Approved, Expired
    
    # Dates
    application_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    approval_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    expiration_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Details
    issuing_authority: Mapped[str | None] = mapped_column(String(255))
    inspector_name: Mapped[str | None] = mapped_column(String(255))
    notes: Mapped[str | None] = mapped_column(Text)
    
    # Workflow columns (added in migration 7efbcd4142a3)
    status_history: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Track status changes
    approved_by: Mapped[str | None] = mapped_column(String(255))  # Who approved
    approved_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))  # When approved
    
    # Phase Q: Qualifier Compliance (added Dec 2025)
    licensed_business_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # FK to licensed_businesses.id
    qualifier_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # FK to qualifiers.id
    license_number_used: Mapped[str | None] = mapped_column(String(100))  # Which license was used on permit application
    responsibility_role: Mapped[str | None] = mapped_column(String(100))  # "General Contractor", "Oversight", "Direct"
    
    # Dynamic fields
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        Index('ix_permits_extra_gin', 'extra', postgresql_using='gin'),
    )


class Inspection(Base):
    """
    Building inspection tracking - first-class schedulable objects linked to permits and projects.
    Part of Buildertrend-influenced architecture for permit workflow.
    """
    __tablename__ = "inspections"
    
    # Primary key - UUID for unique identification
    inspection_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (INS-00001, INS-00002, etc.)
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign keys
    permit_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True, nullable=False)
    project_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True, nullable=False)  # Denormalized for query performance
    
    # Inspection details
    inspection_type: Mapped[str | None] = mapped_column(String(100), index=True)  # Footing, Foundation, Framing, Final, etc.
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Scheduled, Accepted, In-Progress, Completed, Failed, Cancelled
    
    # Scheduling
    scheduled_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    completed_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Inspector assignment
    inspector: Mapped[str | None] = mapped_column(String(255))  # Inspector name or user_id
    assigned_to: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to users table
    
    # Results
    result: Mapped[str | None] = mapped_column(String(50))  # Pass, Fail, Partial, No-Access
    notes: Mapped[str | None] = mapped_column(Text)
    
    # JSONB fields for flexibility
    photos: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Array of {url, gps, timestamp, uploaded_by}
    deficiencies: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Array of {description, severity, photo_refs, status}
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Additional flexible fields
    
    # Phase Q: Qualifier Compliance (added Dec 2025)
    qualifier_attended: Mapped[bool | None] = mapped_column(Boolean)  # Did qualifier attend this inspection?
    oversight_site_visit_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to site_visits.visit_id (if linked to oversight visit)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        Index('ix_inspections_photos_gin', 'photos', postgresql_using='gin'),
        Index('ix_inspections_deficiencies_gin', 'deficiencies', postgresql_using='gin'),
        Index('ix_inspections_extra_gin', 'extra', postgresql_using='gin'),
    )


class Invoice(Base):
    """
    Invoice tracking with QuickBooks sync - supports project billing and permit fees.
    Part of financial workflow for construction projects.
    """
    __tablename__ = "invoices"
    
    # Primary key - UUID for unique identification
    invoice_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (INV-00001, INV-00002, etc.)
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign keys
    project_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True, nullable=False)
    client_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # Denormalized
    
    # QuickBooks integration
    qb_invoice_id: Mapped[str | None] = mapped_column(String(50), unique=True, index=True)
    
    # Invoice details
    invoice_number: Mapped[str | None] = mapped_column(String(50), unique=True, index=True)
    invoice_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    due_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    
    # Amounts
    subtotal: Mapped[float | None] = mapped_column(Numeric(12, 2))
    tax_amount: Mapped[float | None] = mapped_column(Numeric(12, 2))
    total_amount: Mapped[float | None] = mapped_column(Numeric(12, 2))
    balance: Mapped[float | None] = mapped_column(Numeric(12, 2))  # Outstanding balance (legacy)
    
    # Payment tracking (added in migration 1792b711773f)
    amount_paid: Mapped[float | None] = mapped_column(Numeric(12, 2), server_default=text("0"))  # Total payments received
    balance_due: Mapped[float | None] = mapped_column(Numeric(12, 2))  # Calculated: total_amount - amount_paid
    
    # Status
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Draft, Sent, Paid, Overdue, Cancelled
    
    # Line items and details stored as JSONB
    line_items: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # [{description, quantity, rate, amount, item_id}]
    
    # QuickBooks sync tracking
    sync_status: Mapped[str | None] = mapped_column(String(50), index=True)  # pending, synced, failed, conflict
    sync_error: Mapped[str | None] = mapped_column(Text)
    last_sync_attempt: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Notes
    notes: Mapped[str | None] = mapped_column(Text)
    
    # Dynamic fields
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=text("CURRENT_TIMESTAMP"))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=text("CURRENT_TIMESTAMP"), onupdate=datetime.utcnow)
    
    # GIN indexes for JSONB fields
    __table_args__ = (
        Index('ix_invoices_line_items_gin', 'line_items', postgresql_using='gin'),
        Index('ix_invoices_extra_gin', 'extra', postgresql_using='gin'),
    )


class Payment(Base):
    """
    Payment tracking with QuickBooks sync - supports invoice payments and general receipts.
    Part of financial workflow for construction projects.
    """
    __tablename__ = "payments"
    
    # Primary key - UUID for unique identification
    payment_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (PAY-00001, PAY-00002, etc.)
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign keys
    invoice_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # Link to invoice
    client_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)
    project_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)
    
    # QuickBooks integration
    qb_payment_id: Mapped[str | None] = mapped_column(String(50), unique=True, index=True)
    
    # Payment details
    amount: Mapped[float | None] = mapped_column(Numeric(12, 2))
    payment_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    payment_method: Mapped[str | None] = mapped_column(String(50))  # Check, Credit Card, Wire, Cash, ACH
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Pending, Cleared, Failed, Refunded
    
    # References
    reference_number: Mapped[str | None] = mapped_column(String(50))  # Check number or transaction ID
    check_number: Mapped[str | None] = mapped_column(String(50))
    transaction_id: Mapped[str | None] = mapped_column(String(100))
    
    # QuickBooks sync tracking
    sync_status: Mapped[str | None] = mapped_column(String(50), index=True)  # pending, synced, failed, conflict
    sync_error: Mapped[str | None] = mapped_column(Text)
    last_sync_attempt: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Notes
    notes: Mapped[str | None] = mapped_column(Text)
    
    # Dynamic fields
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        Index('ix_payments_extra_gin', 'extra', postgresql_using='gin'),
    )


class SiteVisit(Base):
    """
    Site visit tracking - field visits for pre-construction, progress checks, walkthroughs, and punch lists.
    Supports photo upload, deficiency tracking, and follow-up action creation.
    """
    __tablename__ = "site_visits"
    
    # Primary key - UUID for unique identification
    visit_id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (SV-00001, SV-00002, etc.)
    business_id: Mapped[str | None] = mapped_column(String(20), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign keys
    project_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True, nullable=False)
    client_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # Denormalized
    
    # Visit details
    visit_type: Mapped[str | None] = mapped_column(String(100), index=True)  # Pre-Construction, Progress, Final Walkthrough, Punch List, Client Meeting
    status: Mapped[str | None] = mapped_column(String(50), index=True)  # Scheduled, In-Progress, Completed, Cancelled
    
    # Scheduling
    scheduled_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), index=True)
    start_time: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))  # Actual check-in time
    end_time: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))  # Actual check-out time
    
    # Attendees (JSONB array of objects)
    attendees: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # [{name, role, email, phone}]
    
    # Location
    gps_location: Mapped[str | None] = mapped_column(String(100))  # lat,lon format
    
    # Photos (JSONB array of objects)
    photos: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # [{url, gps, timestamp, uploaded_by, caption}]
    
    # Notes and observations
    notes: Mapped[str | None] = mapped_column(Text)
    weather: Mapped[str | None] = mapped_column(String(100))  # Weather conditions during visit
    
    # Deficiencies found (JSONB array of objects)
    deficiencies: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # [{description, severity, location, photo_refs, status}]
    
    # Follow-up actions (JSONB array of objects)
    follow_up_actions: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # [{type, status, created_entity_id, description}]
    # type: 'inspection', 'change_order', 'punchlist'
    # status: 'pending', 'created', 'completed'
    # created_entity_id: UUID of created inspection/change_order/punchlist
    
    # Assignment
    created_by: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to users
    assigned_to: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to users
    
    # Phase Q: Qualifier Compliance (added Dec 2025)
    oversight_type: Mapped[str | None] = mapped_column(String(100))  # "General", "Pre-Pour", "Framing", "Final", "Client Meeting"
    qualifier_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)  # FK to qualifiers.id
    qualifier_present: Mapped[bool | None] = mapped_column(Boolean)  # Was qualifier physically present?
    oversight_justification: Mapped[str | None] = mapped_column(Text)  # Why this visit was needed (compliance notes)
    
    # Dynamic fields
    extra: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=text("CURRENT_TIMESTAMP"))
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=text("CURRENT_TIMESTAMP"), onupdate=datetime.utcnow)
    
    # GIN indexes for JSONB fields
    __table_args__ = (
        Index('ix_site_visits_attendees_gin', 'attendees', postgresql_using='gin'),
        Index('ix_site_visits_photos_gin', 'photos', postgresql_using='gin'),
        Index('ix_site_visits_deficiencies_gin', 'deficiencies', postgresql_using='gin'),
        Index('ix_site_visits_follow_up_actions_gin', 'follow_up_actions', postgresql_using='gin'),
        Index('ix_site_visits_extra_gin', 'extra', postgresql_using='gin'),
    )


class QuickBooksToken(Base):
    """
    QuickBooks OAuth2 tokens - migrated from 'QB_Tokens' sheet.
    
    Stores access/refresh tokens with automatic expiry tracking.
    Supports multiple environments (sandbox/production) and token revocation.
    """
    __tablename__ = "quickbooks_tokens"
    
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    
    # OAuth tokens
    realm_id: Mapped[str] = mapped_column(String(50), unique=True, index=True)
    access_token: Mapped[str] = mapped_column(Text)
    refresh_token: Mapped[str] = mapped_column(Text)
    
    # Expiry tracking
    access_token_expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    refresh_token_expires_at: Mapped[datetime] = mapped_column(DateTime(timezone=True))
    
    # Environment and status
    environment: Mapped[str] = mapped_column(String(20), default="production")  # sandbox, production
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, index=True)  # For token revocation
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )


class QuickBooksCustomerCache(Base):
    """
    Cache for QuickBooks customer data to reduce API calls.
    
    TTL-based cache refreshed every 2 minutes during active use.
    """
    __tablename__ = "quickbooks_customers_cache"
    
    # QuickBooks customer ID as primary key
    qb_customer_id: Mapped[str] = mapped_column(String(50), primary_key=True)
    
    # QB data snapshot
    display_name: Mapped[str | None] = mapped_column(String(255))
    company_name: Mapped[str | None] = mapped_column(String(255))
    given_name: Mapped[str | None] = mapped_column(String(255))
    family_name: Mapped[str | None] = mapped_column(String(255))
    email: Mapped[str | None] = mapped_column(String(255))
    phone: Mapped[str | None] = mapped_column(String(50))
    
    # Full QB response
    qb_data: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Cache metadata
    cached_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP"),
        index=True
    )
    
    __table_args__ = (
        Index('ix_qb_customers_cached_at', 'cached_at'),
    )


class User(Base):
    """
    Application user table - maps to Supabase Auth users.
    
    Design:
    - supabase_user_id: Links to auth.users.id (Supabase Auth table)
    - email/full_name: Duplicated for performance (avoid joins to auth schema)
    - role: App-specific RBAC (admin, pm, inspector, client, finance)
    - app_metadata: Flexible JSONB for permissions, preferences, settings
    
    Supabase Auth handles:
    - Password hashing, email verification, password reset
    - JWT token generation and validation
    - OAuth/SSO integrations
    
    This table handles:
    - App-specific roles and permissions
    - User profile data and preferences
    - Activity tracking
    """
    __tablename__ = "users"
    
    # Primary key - internal UUID
    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Supabase Auth user ID - maps to auth.users.id (nullable for local users)
    supabase_user_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), unique=True, index=True)
    
    # User profile (duplicated from auth.users for performance)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    full_name: Mapped[str | None] = mapped_column(String(255))
    phone: Mapped[str | None] = mapped_column(String(50))
    
    # Authentication (for local users not using Supabase Auth)
    # Note: Column removed from database - Supabase Auth handles password hashing
    # password_hash: Mapped[str | None] = mapped_column(String(255))
    
    # Role-based access control
    # Valid roles: admin, pm, inspector, client, finance
    role: Mapped[str] = mapped_column(String(50), server_default="client", index=True)
    
    # Status flags
    is_active: Mapped[bool] = mapped_column(Boolean, server_default="true")
    is_email_verified: Mapped[bool] = mapped_column(Boolean, server_default="false")
    
    # Phase Q: Qualifier flag (added Dec 2025) - UI convenience only, NOT authoritative
    # Authoritative qualifier status comes from qualifiers table (1:1 via qualifiers.user_id FK)
    is_qualifier: Mapped[bool | None] = mapped_column(Boolean, server_default="false")
    
    # Activity tracking
    last_login_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    # last_activity_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # App-specific metadata
    # Example: {"permissions": ["view_permits"], "preferences": {"theme": "dark"}}
    app_metadata: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Audit fields
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP")
    )
    
    __table_args__ = (
        # GIN index for JSONB queries
        Index('ix_users_app_metadata_gin', 'app_metadata', postgresql_using='gin'),
        # Case-insensitive email search
        Index('ix_users_email_lower', text('lower(email)')),
    )


class QuickBooksInvoiceCache(Base):
    """
    Cache for QuickBooks invoice data.
    """
    __tablename__ = "quickbooks_invoices_cache"
    
    # QuickBooks invoice ID as primary key
    qb_invoice_id: Mapped[str] = mapped_column(String(50), primary_key=True)
    
    # Invoice summary
    customer_id: Mapped[str | None] = mapped_column(String(50), index=True)
    doc_number: Mapped[str | None] = mapped_column(String(50))
    total_amount: Mapped[float | None] = mapped_column(Numeric(12, 2))
    balance: Mapped[float | None] = mapped_column(Numeric(12, 2))
    due_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Full QB response
    qb_data: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Cache metadata
    cached_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP"),
        index=True
    )


class QuickBooksPaymentCache(Base):
    """
    Cache for QuickBooks payment data to reduce API calls.
    
    TTL-based cache refreshed during active use.
    """
    __tablename__ = "quickbooks_payments_cache"
    
    # QuickBooks payment ID as primary key
    qb_payment_id: Mapped[str] = mapped_column(String(50), primary_key=True)
    
    # Payment summary
    customer_id: Mapped[str | None] = mapped_column(String(50), index=True)
    total_amount: Mapped[float | None] = mapped_column(Numeric(12, 2))
    payment_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    payment_method: Mapped[str | None] = mapped_column(String(50))  # Check, Cash, CreditCard, etc.
    payment_ref_num: Mapped[str | None] = mapped_column(String(100))  # Check number or reference
    
    # Full QB response (includes linked invoices)
    qb_data: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)
    
    # Cache metadata
    cached_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP"),
        index=True
    )
    
    __table_args__ = (
        Index('ix_qb_payments_cached_at', 'cached_at'),
        Index('ix_qb_payments_payment_date', 'payment_date'),
    )


class LicensedBusiness(Base):
    """
    Licensed businesses holding NCLBGC licenses (Phase Q).
    
    Business entities that can legally perform general contracting in NC.
    May have multiple qualifiers over time.
    """
    __tablename__ = "licensed_businesses"
    
    # Primary key - UUID for unique identification
    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Business ID - human-friendly immutable ID (LB-00001, LB-00002, etc.)
    # Generated by database trigger, don't include in INSERT
    business_id: Mapped[str] = mapped_column(String(50), unique=True, index=True, server_default=FetchedValue())
    
    # Core identity
    business_name: Mapped[str] = mapped_column(String(255), index=True)  # DBA/trade name
    legal_name: Mapped[str] = mapped_column(String(255))  # Legal entity name
    dba_name: Mapped[str | None] = mapped_column(String(255))  # If different from business_name
    
    # License information
    license_number: Mapped[str] = mapped_column(String(100), unique=True, index=True)  # NC license number (e.g., "85538")
    license_type: Mapped[str] = mapped_column(String(100))  # "Unlimited", "Intermediate", "Limited"
    license_status: Mapped[str] = mapped_column(String(50), index=True, server_default=text("'active'"))  # active, inactive, suspended, revoked
    license_issue_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))  # Date only
    license_expiration_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))  # Date only
    
    # Denormalized qualifier link (convenience only, NOT used in enforcement)
    # Use licensed_business_qualifiers table for actual relationships
    qualifying_user_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False), index=True)
    
    # Business operations
    fee_model: Mapped[str | None] = mapped_column(String(50))  # "hourly", "fixed", "cost_plus"
    active: Mapped[bool] = mapped_column(Boolean, server_default=text("true"), index=True)
    
    # Contact info
    address: Mapped[str | None] = mapped_column(Text)
    phone: Mapped[str | None] = mapped_column(String(50))
    email: Mapped[str | None] = mapped_column(String(255))
    notes: Mapped[str | None] = mapped_column(Text)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )


class Qualifier(Base):
    """
    Individual qualifiers with NCLBGC qualifier status (Phase Q).
    
    Maps 1:1 to User via user_id FK. Each qualifier can serve up to 2 licensed businesses.
    """
    __tablename__ = "qualifiers"
    
    # Primary key - UUID for unique identification
    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Qualifier ID - human-friendly immutable ID (QF-00001, QF-00002, etc.)
    # Generated by database trigger, don't include in INSERT
    qualifier_id: Mapped[str] = mapped_column(String(50), unique=True, index=True, server_default=FetchedValue())
    
    # 1:1 relationship with User (unique constraint enforced)
    user_id: Mapped[str] = mapped_column(UUID(as_uuid=False), unique=True, index=True)
    
    # Core identity
    full_name: Mapped[str] = mapped_column(String(255))  # Synced from users.full_name
    
    # NC qualifier license information
    qualifier_id_number: Mapped[str] = mapped_column(String(100), unique=True, index=True)  # NC qualifier ID (e.g., "59510")
    license_type: Mapped[str] = mapped_column(String(100))  # "Unlimited", "Intermediate", "Limited"
    license_status: Mapped[str] = mapped_column(String(50), index=True, server_default=text("'active'"))  # active, inactive, suspended, revoked
    license_issue_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))  # Date only
    license_expiration_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))  # Date only
    
    # Capacity enforcement
    max_licenses_allowed: Mapped[int] = mapped_column(server_default=text("2"))  # NC law: max 2 Licensed Businesses
    
    # Contact (optional - may use user contact info instead)
    email: Mapped[str | None] = mapped_column(String(255))
    phone: Mapped[str | None] = mapped_column(String(50))
    notes: Mapped[str | None] = mapped_column(Text)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )


class LicensedBusinessQualifier(Base):
    """
    Junction table for Licensed Business <-> Qualifier relationships (Phase Q).
    
    Enforces capacity limits (max 2 businesses per qualifier) and time bounds.
    Includes cutoff_date for tracking when oversight ended.
    """
    __tablename__ = "licensed_business_qualifiers"
    
    # Primary key - UUID for unique identification
    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Foreign keys
    licensed_business_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True)
    qualifier_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True)
    
    # Time bounds
    start_date: Mapped[datetime] = mapped_column(DateTime(timezone=False))  # Date only - when qualification began
    end_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=False))  # Date only - when qualification ended (NULL = ongoing)
    cutoff_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))  # Timestamp - when oversight must stop (last day at 11:59 PM)
    
    # Relationship metadata
    relationship_type: Mapped[str] = mapped_column(String(100), server_default=text("'qualification'"))  # "qualification", "temporary", "interim"
    notes: Mapped[str | None] = mapped_column(Text)
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        # Unique constraint: only one active relationship per business-qualifier pair
        # "Active" = end_date IS NULL (checked by unique partial index in migration)
        Index('uq_lbq_active_pair', 'licensed_business_id', 'qualifier_id', unique=True, postgresql_where=text("end_date IS NULL")),
        Index('ix_lbq_qualifier_id', 'qualifier_id'),
        Index('ix_lbq_licensed_business_id', 'licensed_business_id'),
        Index('ix_lbq_dates', 'start_date', 'end_date'),
    )


class OversightAction(Base):
    """
    Canonical compliance record for qualifier oversight (Phase Q).
    
    Immutable audit trail of site visits, plan reviews, permit reviews, client meetings.
    Enforces cutoff_date (no actions after qualifier relationship ends).
    """
    __tablename__ = "oversight_actions"
    
    # Primary key - UUID for unique identification
    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Action ID - human-friendly immutable ID (OA-00001, OA-00002, etc.)
    # Generated by database trigger, don't include in INSERT
    action_id: Mapped[str] = mapped_column(String(50), unique=True, index=True, server_default=FetchedValue())
    
    # Foreign keys (all required - full context for every action)
    project_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True)  # FK to projects.project_id
    licensed_business_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True)  # FK to licensed_businesses.id
    qualifier_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True)  # FK to qualifiers.id
    licensed_business_qualifier_id: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to licensed_business_qualifiers.id (optional for historical lookup)
    
    # Action details
    action_type: Mapped[str] = mapped_column(String(100), index=True)  # site_visit, plan_review, permit_review, client_meeting, inspection_attendance, phone_consultation
    action_date: Mapped[datetime] = mapped_column(DateTime(timezone=True), index=True)  # CRITICAL: Used by cutoff_date trigger for enforcement
    duration_minutes: Mapped[int | None] = mapped_column()  # Optional: how long the action took
    
    # Location and participants
    location: Mapped[str | None] = mapped_column(String(255))  # Where action occurred
    attendees: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Array of {name, role} objects
    
    # Documentation
    notes: Mapped[str | None] = mapped_column(Text)
    photos: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Array of photo URLs or references
    
    # Audit
    created_by: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to users.id
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        Index('ix_oversight_actions_project_date', 'project_id', 'action_date'),
        Index('ix_oversight_actions_action_type', 'action_type'),
    )


class ComplianceJustification(Base):
    """
    Audit log for compliance rule overrides and manual interventions (Phase Q).
    
    Records why triggers were bypassed or manual corrections made.
    Includes approval workflow tracking.
    """
    __tablename__ = "compliance_justifications"
    
    # Primary key - UUID for unique identification
    id: Mapped[str] = mapped_column(UUID(as_uuid=False), primary_key=True, server_default=text("gen_random_uuid()"))
    
    # Justification ID - human-friendly immutable ID (CJ-00001, CJ-00002, etc.)
    # Generated by database trigger, don't include in INSERT
    justification_id: Mapped[str] = mapped_column(String(50), unique=True, index=True, server_default=FetchedValue())
    
    # What rule was overridden
    rule_type: Mapped[str] = mapped_column(String(100), index=True)  # "capacity_limit", "cutoff_date", "oversight_minimum"
    entity_type: Mapped[str] = mapped_column(String(100))  # "qualifier", "licensed_business", "project"
    entity_id: Mapped[str] = mapped_column(UUID(as_uuid=False), index=True)  # ID of affected entity
    
    # Why override was needed
    justification_text: Mapped[str] = mapped_column(Text)  # Required explanation
    risk_assessment: Mapped[str | None] = mapped_column(Text)  # Optional risk analysis
    
    # Approval workflow
    requested_by: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to users.id
    approved_by: Mapped[str | None] = mapped_column(UUID(as_uuid=False))  # FK to users.id
    approval_status: Mapped[str] = mapped_column(String(50), server_default=text("'pending'"))  # pending, approved, rejected
    approved_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    
    # Supporting documentation
    supporting_docs: Mapped[Dict[str, Any] | None] = mapped_column(JSONB)  # Array of document references
    
    # Audit
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), 
        server_default=text("CURRENT_TIMESTAMP")
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=text("CURRENT_TIMESTAMP"),
        onupdate=datetime.utcnow
    )
    
    __table_args__ = (
        Index('ix_compliance_justifications_entity', 'entity_type', 'entity_id'),
        Index('ix_compliance_justifications_rule_type', 'rule_type'),
        Index('ix_compliance_justifications_approval_status', 'approval_status'),
    )


__all__ = [
    'Base',
    'Client',
    'Project',
    'Permit',
    'Payment',
    'User',
    'QuickBooksToken',
    'QuickBooksCustomerCache',
    'QuickBooksInvoiceCache',
    'QuickBooksPaymentCache',
    'LicensedBusiness',
    'Qualifier',
    'LicensedBusinessQualifier',
    'OversightAction',
    'ComplianceJustification',
]
